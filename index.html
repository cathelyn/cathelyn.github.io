<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">

	<title>Brno Accident Data Visualization</title>

	<!--	<link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet">-->
	<script src="https://kit.fontawesome.com/1f4d66b7c3.js" crossorigin="anonymous"></script>

	<link rel="shortcut icon" type="image/png" href="docs/images/favicon.png" />
	<link rel="stylesheet" href="css/style.css" />
	<link rel="stylesheet" href="leaflet/leaflet.css" />
	<link rel="stylesheet" href="css/LeafletStyleSheet.css" />
	<link rel="stylesheet" href="css/leaflet-sidebar.css" />
	<link rel="stylesheet" href="css/leaflet-tag-filter-button.css" />
	<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/daterangepicker/daterangepicker.css" />

	<!-- CSS only -->
	<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">


	<script type="text/javascript" src="https://cdn.jsdelivr.net/jquery/latest/jquery.min.js"></script>
	<script type="text/javascript" src="https://cdn.jsdelivr.net/momentjs/latest/moment.min.js"></script>
	<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/daterangepicker/daterangepicker.min.js"></script>


	<!--	Leaflet -->
	<script src="leaflet/leaflet.js"></script>
	<!--	Prune clustering-->
	<script src="js/PruneCluster.js"></script>
	<!--	Leaflet sidebar-->
	<script src="js/leaflet-sidebar.js"></script>
	<!--	Filtering -->
	<script src="js/leaflet-easy-button.js"></script>
	<script src="js/leaflet-tag-filter-button.js"></script>
	<!--	Leaflet Shapefile	-->
	<script src="js/leaflet.shpfile.js"></script>
	<script src="js/shp.js"></script>
	<script src="js/catiline.js"></script>
	<!--	Bootstrap -->
	<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM" crossorigin="anonymous"></script>


	<!--	Data sources TODO: Find better way to store-->

	<script src="sources/bike_accidents.js"></script>
	<script src="sources/traffic_accidents.js"></script>
	<script src="sources/ped_accidents.js"></script>
	<script src="sources/pub_trans_stops_lat_lon_name.js"></script>
	<script src="sources/street_lights_lat_lon_date.js"></script>

</head>
<body>

<!-- SIDEBAR -->
<div id="sidebar" class="sidebar collapsed">
	<!-- Nav tabs -->
	<div class="sidebar-tabs">
		<ul role="tablist">
			<li><a href="#home" role="tab"><i class="fa fa-bars"></i></a></li>
			<li ><a href="#layers" role="tab"><i class="fa-solid fa-layer-group"></i></a></li>
			<li><a href="#dates" role="tab"><i class="fa-solid fa-calendar-days"></i></a></li>
			<li ><a href="#filter" role="tab"><i class="fa-solid fa-filter"></i></a></li>
		</ul>

		<ul role="tablist">
			<li><a href="#settings" role="tab"><i class="fa fa-gear"></i></a></li>
		</ul>
	</div>

	<!-- Tab panes -->
	<div class="sidebar-content">
		<div class="sidebar-pane" id="home">
			<h1 class="sidebar-header">
				Brno accident data visualization
				<span class="sidebar-close"><i class="fa fa-caret-left"></i></span>
			</h1>
			<!--			TODO: Decide what to do with this menu -->
			This is a project.

		</div>

		<div class="sidebar-pane" id="layers">
			<h1 class="sidebar-header">Layers selection<span class="sidebar-close"><i class="fa fa-caret-left"></i></span>
			</h1>
			<script>
				function generateOverlaysControl() {
					let outputEl = document.getElementById("layer_selector");
					const ulMain = document.createElement('ul')

					Object.keys(overlaysGrouped).forEach(group => {
						const liGroup = document.createElement('li');
						liGroup.classList.add('overlayGroup');
						liGroup.classList.add('form-check');
						liGroup.classList.add('form-switch');
						// liGroup.innerHTML = group;

						const checkbox = document.createElement('input');
						checkbox.classList.add("form-check-input")
						checkbox.type = "checkbox";
						checkbox.name = group;
						checkbox.id = "chb_" + group.replace(" ", "_");

						// label for the checkbox
						const label = document.createElement('label');
						label.classList.add("form-check-label");
						label.htmlFor = "chb_" + group.replace(" ", "_");

						// label tag
						label.appendChild(document.createTextNode(group));

						liGroup.appendChild(checkbox);
						liGroup.appendChild(label)


						checkbox.addEventListener("change", function () {
							const trigger = new Event("click");
							const groupItems = this.parentElement.getElementsByTagName('li');
							for (const item of groupItems) {
								if (this.checked){
									if (!item.classList.contains("enabled"))
										item.dispatchEvent(trigger);
								} else {
									if (item.classList.contains("enabled")){
										item.dispatchEvent(trigger);
									}
								}
							}
						})



						ulMain.appendChild(liGroup)
						const ulNestedGroup = document.createElement('ul');
						liGroup.appendChild(ulNestedGroup);
						Object.keys(overlaysGrouped[group]).forEach(layerName => {
							const liLayer = document.createElement('li');
							liLayer.classList.add('overlayLayer');
							liLayer.innerHTML = layerName;
							liLayer.addEventListener("click", function() {
								if (layerName.toString().includes("Traffic accidents")) {
									toggleTrafficAccidents(this);
									return;
								} else if (layerName.toString().includes("Bike accidents")){
									toggleBikeAccidents(this);
									return;
								} else if (layerName.toString().includes("Pedestrian accidents")) {
									togglePedestrianAccidents(this);
									return;
								}
								if (!this.classList.contains("enabled")) {
									this.classList.add("enabled");
									map.addLayer(overlaysGrouped[group][layerName]);
								} else if (this.classList.contains("enabled")) {
									this.classList.remove("enabled")
									map.removeLayer(overlaysGrouped[group][layerName]);
								}
							});
							ulNestedGroup.appendChild(liLayer);
						})
					})
					outputEl.appendChild(ulMain);
				}

			</script>
			<div id="layer_selector">

			</div>

		</div>

		<div class="sidebar-pane" id="dates">
			<h1 class="sidebar-header">Date selector<span class="sidebar-close"><i class="fa fa-caret-left"></i></span></h1>
			<script>
				function activate_date_selector() {
					let range_selector = document.getElementById('date_range_selector').checked;
					if (range_selector) {
						document.getElementById('custom_date_selector_form').childNodes.forEach(value => value.disabled = true);
						document.getElementById('date_range_selector_form').childNodes.forEach(value => value.disabled = false);
					} else {
						document.getElementById('custom_date_selector_form').childNodes.forEach(value => value.disabled = false);
						document.getElementById('date_range_selector_form').childNodes.forEach(value => value.disabled = true);
					}
				}
			</script>
			<div>
				<form>
					<input id="date_range_selector" type="radio" name="date_selector_method" checked onclick=activate_date_selector()>
					<label for="date_range_selector">Date range</label><br>

					<input id="custom_date_selector" type="radio" name="date_selector_method" onclick=activate_date_selector()>
					<label for="custom_date_selector">Custom date selector</label>
				</form>
			</div>
			<hr>
			<div id="date_range_selector_form">
				<label for="date_range"><h2>Date range</h2></label>

				<input id="date_range" type="text" name="dates" />
				<script>
					$('input[name="dates"]').daterangepicker({
								opens: 'right',
								startDate: "01/01/2010",
								endDate: "12/31/2021",
								showDropdowns: true,
								minYear: 2010,
								maxYear: 2021,
							},
							function(start, end, label) {
								DateRangeFilter(start, end);
							}
					);
				</script>
			</div>
			<hr>
			<div id="custom_date_selector_form">
				<h2>Custom date selector</h2>
				<fieldset disabled>
					<label>
						<input type="checkbox" name="fields">
					</label>
					<label for="year">Year:</label>
					<select id="year" multiple>
						<option value=2010>2010</option>
						<option value=2011>2011</option>
						<option value=2012>2012</option>
						<option value=2013>2013</option>
						<option value=2014>2014</option>
						<option value=2015>2015</option>
						<option value=2016>2016</option>
						<option value=2017>2017</option>
						<option value=2018>2018</option>
						<option value=2019>2019</option>
						<option value=2020>2020</option>
						<option value=2021>2021</option>
					</select>
				</fieldset>
				<fieldset disabled>
					<label>
						<input type="checkbox" name="fields">
					</label>
					<label for="month">Month of the year:</label>

					<select id="month">
						<option value=0>January</option>
						<option value=1>February</option>
						<option value=2>March</option>
						<option value=3>April</option>
						<option value=4>May</option>
						<option value=5>June</option>
						<option value=6>July</option>
						<option value=7>August</option>
						<option value=8>September</option>
						<option value=9>October</option>
						<option value=10>November</option>
						<option value=11>December</option>
					</select>
				</fieldset>

				<fieldset disabled>
					<label>
						<input type="checkbox" name="fields">
					</label>
					<label for="day">Day of the month:</label>

					<select id="day" >
						<option value=1>1</option>
						<option value=2>2</option>
						<option value=3>3</option>
						<option value=4>4</option>
						<option value=5>5</option>
						<option value=6>6</option>
						<option value=7>7</option>
						<option value=8>8</option>
						<option value=9>9</option>
						<option value=10>10</option>
						<option value=11>11</option>
						<option value=12>12</option>
						<option value=13>13</option>
						<option value=14>14</option>
						<option value=15>15</option>
						<option value=16>16</option>
						<option value=17>17</option>
						<option value=18>18</option>
						<option value=19>19</option>
						<option value=20>20</option>
						<option value=21>21</option>
						<option value=22>22</option>
						<option value=23>23</option>
						<option value=24>24</option>
						<option value=25>25</option>
						<option value=26>26</option>
						<option value=27>27</option>
						<option value=28>28</option>
						<option value=29>29</option>
						<option value=30>30</option>
						<option value=31>31</option>
					</select>
				</fieldset>
				<fieldset disabled>
					<label>
						<input type="checkbox" name="fields">
					</label>
					<label for="weekday">Day of the week:</label>

					<select id="weekday">
						<option value=1>Monday</option>
						<option value=2">Tuesday</option>
						<option value=3">Wednesday</option>
						<option value=4">Thursday</option>
						<option value=5">Friday</option>
						<option value=6">Saturday</option>
						<option value=7>Sunday</option>
					</select>
				</fieldset>
				<button type="submit" onclick="DateCustomSelect()">Filter</button>
			</div>
		</div>


		<div class="sidebar-pane" id="filter">
			<h1 class="sidebar-header">Filters<span class="sidebar-close"><i class="fa fa-caret-left"></i></span></h1>
			<div id="filters">


			</div>

		</div>



		<div class="sidebar-pane" id="settings">
			<h1 class="sidebar-header">Settings<span class="sidebar-close"><i class="fa fa-caret-left"></i></span></h1>
		</div>
	</div>
</div>


<div id="map" class="sidebar-map" style="width: 100vw; height: 100vh;"></div>

<script>
	// CONSTANTS
	const categoriesColors = ['rgba(255,75,0,0.6)', 'rgba(160,61,229,0.6)', 'rgba(3,170,234,0.6)'];
	const pi2 = Math.PI * 2;

	// categories configuration
	const trafficCategory = 0
	const bikeCategory = 1
	const pedestrianCategory = 2
	// END CONSTANTS

	// DATA
	// START LAYER SETUP

	// main clustering layer
	let accidentsCluster = new PruneClusterForLeaflet(160);



	// other info layers
	let pedestrianCrossingsLayer = L.layerGroup();
	let publicTransportStopsLayer = L.layerGroup();
	let streetLightsLayer = L.layerGroup();

	// cycling infrastructure
	let cyclingInfraSourceFiles = {
		'BicycleCrossing.shp.zip': L.layerGroup(),
		'BikePath.shp.zip': L.layerGroup(),
		'BikePathInTheOppositeDirection(Lane).shp.zip': L.layerGroup(),
		'CyclistsRidingInTheOppositeDirection.shp.zip': L.layerGroup(),
		'DedicatedBicycleLane.shp.zip': L.layerGroup(),
		'EntryAllowedForCyclists.shp.zip': L.layerGroup(),
		'MarkedCorridorForCyclists.shp.zip': L.layerGroup(),
		'NoEntryForAllMotorVehicles.shp.zip': L.layerGroup(),
		'Others.shp.zip': L.layerGroup(),
		'PathForPedestriansAndCyclists(Separated).shp.zip': L.layerGroup(),
		'PathForPedestriansAndCyclists(Unseparated).shp.zip': L.layerGroup(),
		'PedestrianPathWithCyclistsAllowed.shp.zip': L.layerGroup(),
		'ProhibitedEntryForCyclists.shp.zip': L.layerGroup(),
		'ProtectiveLaneForCyclists.shp.zip': L.layerGroup(),
		'ReservedLaneForTaxi_Bicycle_Bus.shp.zip': L.layerGroup(),
		'TheSectionWasCanceled.shp.zip': L.layerGroup()
	}

	// street slopes
	let streetSlopeSourceFiles = {
		'Extreme.shp.zip': L.layerGroup(),
		'Dangerous.shp.zip': L.layerGroup(),
		'Medium.shp.zip': L.layerGroup(),
		'Min.shp.zip': L.layerGroup()
	}


	const overlaysGrouped = {
		"Accidents" : {
			"<span id='traffic_accidents'><i class='fa fa-map-marker red'></i> Traffic accidents</span>": accidentsCluster,
			"<span id='bike_accidents'><i class='fa fa-map-marker violet'></i> Bike accidents</span>": accidentsCluster,
			"<span id='pedestrian_accidents'><i class='fa fa-map-marker blue'></i> Pedestrian accidents</span>": accidentsCluster,
		}, "Architecture": {
			"<i class='fa-regular fa-lightbulb'></i> Street lights": streetLightsLayer,
			"<i class='fa-solid fa-bus'></i> Bus Stops": publicTransportStopsLayer,
			"<i class='fa-solid fa-person-walking'></i> Pedestrian Crossings": pedestrianCrossingsLayer,
		}, "Cycling infrastrucure": {
			"<i class='fa-solid fa-bicycle'></i> Bicycle Crossing": cyclingInfraSourceFiles["BicycleCrossing.shp.zip"],
			"<i class='fa-solid fa-bicycle'></i> Bicycle Path": cyclingInfraSourceFiles["BikePath.shp.zip"],
			"<i class='fa-solid fa-bicycle'></i> Separate Line for Taxi, Bicycle, Bus": cyclingInfraSourceFiles["ReservedLaneForTaxi_Bicycle_Bus.shp.zip"],
			"<i class='fa-solid fa-bicycle'></i> Bicycle Path in the Opposite direction (Lane)": cyclingInfraSourceFiles["BikePathInTheOppositeDirection(Lane).shp.zip"],
			"<i class='fa-solid fa-bicycle'></i> Cyclists riding in the opposite direction": cyclingInfraSourceFiles["CyclistsRidingInTheOppositeDirection.shp.zip"],
			"<i class='fa-solid fa-bicycle'></i> Dedicated bicycle line": cyclingInfraSourceFiles["DedicatedBicycleLane.shp.zip"],
			"<i class='fa-solid fa-bicycle'></i> Protective Line for Cyclists": cyclingInfraSourceFiles["ProtectiveLaneForCyclists.shp.zip"],
			"<i class='fa-solid fa-bicycle'></i> Marked Corridor for Cyclists": cyclingInfraSourceFiles["MarkedCorridorForCyclists.shp.zip"],
			"<i class='fa-solid fa-bicycle'></i> Entry Allowed for Cyclists": cyclingInfraSourceFiles["EntryAllowedForCyclists.shp.zip"],
			"<i class='fa-solid fa-bicycle'></i> No Entry for All Motor Vehicles": cyclingInfraSourceFiles["NoEntryForAllMotorVehicles.shp.zip"],
			"<i class='fa-solid fa-bicycle'></i> Path for Pedestrians and Cyclists (Separated)": cyclingInfraSourceFiles["PathForPedestriansAndCyclists(Separated).shp.zip"],
			"<i class='fa-solid fa-bicycle'></i> Path for Pedestrians and Cyclists (Joint)": cyclingInfraSourceFiles["PathForPedestriansAndCyclists(Unseparated).shp.zip"],
			"<i class='fa-solid fa-bicycle'></i> Pedestrian Path with Cyclists Allowed": cyclingInfraSourceFiles["PedestrianPathWithCyclistsAllowed.shp.zip"],
			"<i class='fa-solid fa-bicycle'></i> Prohibited Entry for Cyclists": cyclingInfraSourceFiles["ProhibitedEntryForCyclists.shp.zip"],
			"<i class='fa-solid fa-bicycle'></i> Canceled sections": cyclingInfraSourceFiles["TheSectionWasCanceled.shp.zip"],
			"<i class='fa-solid fa-bicycle'></i> Others": cyclingInfraSourceFiles["Others.shp.zip"],
		}, "Street slopes": {
			"<i class='fa-solid fa-arrow-up-right-dots'></i> Minimal (<5%)": streetSlopeSourceFiles["Min.shp.zip"],
			"<i class='fa-solid fa-arrow-up-right-dots'></i> Medium (5%-10%)": streetSlopeSourceFiles["Medium.shp.zip"],
			"<i class='fa-solid fa-arrow-up-right-dots'></i> Dangerous (10%-20%)": streetSlopeSourceFiles["Dangerous.shp.zip"],
			"<i class='fa-solid fa-arrow-up-right-dots'></i> Extreme (>20%)": streetSlopeSourceFiles["Extreme.shp.zip"]
		}
	}
	// END LAYER SETUP

	// START ICON (MARKER) GENERATOR
	// icons for separate categories
	accidentsCluster.BuildLeafletClusterIcon = function(cluster) {
		let e = new L.Icon.MarkerCluster();

		e.stats = cluster.stats;
		e.population = cluster.population;
		return e;
	};

	L.Icon.MarkerCluster = L.Icon.extend({
		options: {
			iconSize: new L.Point(44, 44),
			className: 'prunecluster leaflet-markercluster-icon'
		},

		createIcon: function () {
			// based on L.Icon.Canvas from shramov/leaflet-plugins (BSD licence)
			let e = document.createElement('canvas');
			this._setIconStyles(e, 'icon');
			let s = this.options.iconSize;
			e.width = s.x;
			e.height = s.y;
			this.draw(e.getContext('2d'), s.x, s.y);
			return e;
		},

		createShadow: function () {
			return null;
		},

		draw: function(canvas) {
			let start = 0;
			for (let i = 0, l = categoriesColors.length; i < l; ++i) {

				let size = this.stats[i] / this.population;


				if (size > 0) {
					canvas.beginPath();
					canvas.moveTo(22, 22);
					canvas.fillStyle = categoriesColors[i];
					let from = start,
							to = start + size * pi2;

					if (to < from) {
						from = start;
					}
					canvas.arc(22,22,22, from, to);

					start = start + size*pi2;
					canvas.lineTo(22,22);
					canvas.fill();
					canvas.closePath();
				}

			}

			canvas.beginPath();
			canvas.fillStyle = "rgba(255, 255, 255, 0)"; // TODO: Ask about this
			let diameter = 13;
			canvas.arc(22, 22, diameter, 0, Math.PI*2);
			canvas.fill();
			canvas.closePath();

			canvas.fillStyle = '#000000';
			canvas.textAlign = 'center';
			canvas.textBaseline = 'middle';
			canvas.font = 'bold 12px sans-serif';

			canvas.fillText(this.population, 22, 22, 40);
		}
	});

	function fontAwesomeMapMarkerIcon()	{
		return new L.divIcon({
					html: '<i class="fa fa-map-marker fa-2x"></i>',
					iconSize: [40, 40],
					className: "MapMarkerIcon",
				}
		)
	}

	// END ICON (MARKER) GENERATOR

	// START MARKER GENERATOR FROM DATA

	// markers storage for quick adding - deleting
	let trafficAccidentMarkers = [];
	let bikeAccidentMarkers = [];
	let pedestrianAccidentMarkers = [];

	function addAccident(dataset, markersArray, category)
	/**
	 * Create and add markers for the accidents based on the date in @param dataset. Created markers are also stored
	 * in @param markers_array for further manipulation and filtering. Each marker is assigned a respective category.
	 * @param dataset input data in js array format consisting of comma-separated lat,lon,YYYY,MM,DD values
	 * @param markersArray js array for storing created markers
	 * @param category representation of category for filtering/icon composition purposes
	 */
	{
		if (markersArray.length > 0){
			console.log("Registering " + markersArray.length + " markers");
			markersArray.map(marker => {marker.filtered = false})
		} else {

			let color = "black";
			if (category === 0) {
				color = "red";
			}
			else if (category === 1) {
				color = "violet";
			}
			else if (category === 2) {
				color = "blue";
			}


			console.log("Building markers anew - category " + category);
			dataset.forEach(value => {
				let marker = new PruneCluster.Marker(
						value.point_y,
						value.point_x
				);
				marker.date = new Date(value.datetime);
				marker.filtered = true;
				marker.category = category;


				marker.data.tags = [
					value.collision_with,
					value.cause,
					value.alcohol,
					value.caused_by,
					value.road_condition,
					value.weather,
					value.visibility,
					value.view_condition,
					value.accident_place,
					value.road_type
				]

				marker.data.icon = fontAwesomeMapMarkerIcon();
				marker.data.icon.options.className = "MapMarkerIcon " + color;
				let keys = Object.keys(value);
				let info = "";
				for (let i = 0; i < keys.length; i++) {
					info += keys[i] + ": " + value[keys[i]] + "<br>"
				}

				marker.data.popup = info; // TODO: make popup
				marker.data.tooltip = "Number of people in the accident: " // TODO: Make tooltip
				markersArray.push(marker);
				accidentsCluster.RegisterMarker(marker)}
			);
		}
		accidentsCluster.ProcessView();
	}

	function addTrafficAccidents() {
		addAccident(traffic_accidents_json, trafficAccidentMarkers, trafficCategory);
	}

	function addBikeAccidents() {
		addAccident(bike_accidents_json, bikeAccidentMarkers, bikeCategory);
	}

	function addPedestrianAccidents() {
		addAccident(pedestrian_accidents_json, pedestrianAccidentMarkers, pedestrianCategory);
	}

	function removeMarkerSet(marker_set) {
		marker_set.map(marker => {marker.filtered = true})
		accidentsCluster.ProcessView();
	}

	// init the clusters
	addTrafficAccidents();
	addBikeAccidents();
	addPedestrianAccidents();

	public_transportation_stops.forEach(addPublicTransStops);
	street_lights.forEach(addStreetLights);
	addBikeInfrastructure();
	addStreetSlopes();
	addPedestrianCrossings();


	function addPublicTransStops(value) {
		L.circle([value.split(",")[0], value.split(",")[1]], {
			stroke: false,
			fillColor: '#000000',
			fillOpacity: 0.7,
			radius: 2,
		}).addTo(publicTransportStopsLayer).bindPopup(value.split(",")[2]);
	}

	function addStreetLights(value) {
		// TODO: Make this faster (probably run in the bg on startup or use CircleMarker)
		L.circle([value.split(",")[0], value.split(",")[1]], {
			stroke: false,
			fillColor: '#ffac00',
			fillOpacity: 0.5,
			radius: 1.5,
		}).addTo(streetLightsLayer);
	}

	function addStreetSlopes() {
		let colors = ['red', 'orange', 'blue', 'green']
		for (let [pathname, layer_obj] of Object.entries(streetSlopeSourceFiles)){
			let shp = new L.Shapefile('sources/shapefiles/street_slopes/' + pathname, {
				onEachFeature: function(feature, layer) {
					layer.bindPopup("Slope: " + Math.round(feature.properties['slope']) + "%");
				},
				style: function (feature) {
					let selectedColor = colors[Object.keys(streetSlopeSourceFiles).indexOf(pathname)];
					return {color: selectedColor, fillColor: selectedColor}
				}
			}).addTo(layer_obj);
			shp.once("data:loaded", function() {
				console.log("Finished loading " + pathname)
			});
		}
	}

	function addPedestrianCrossings() {
		let shp = new L.Shapefile('sources/shapefiles/pedestrian_crossings/Pedestrian_crossings.zip', {
			onEachFeature: function(feature, layer) {
				layer.bindPopup(Object.keys(feature.properties).map(function(k) {
					return k + ": " + feature.properties[k];
				}).join("<br />"), {
					maxHeight: 200
				});
			},
			style: function (feature) {
				return {color: 'black', fillColor: 'black'}
			}
		}).addTo(pedestrianCrossingsLayer);
		shp.once("data:loaded", function() {
			console.log("Finished loading sources/shapefiles/pedestrian_crossings/Pedestrian_crossings.zip")
		});
	}


	function addBikeInfrastructure() {
		for (let [pathname, layer_obj] of Object.entries(cyclingInfraSourceFiles)){
			let shp = new L.Shapefile('sources/shapefiles/cycling_measures/' + pathname, {
				onEachFeature: function(feature, layer) {
					layer.bindPopup(Object.keys(feature.properties).map(function(k) {
						return k + ": " + feature.properties[k];
					}).join("<br />"), {
						maxHeight: 200
					});
				}
			}).addTo(layer_obj);
			shp.once("data:loaded", function() {
				console.log("Finished loading "+pathname)
			});
		}
	}


	let OSM = L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
		maxZoom: 19,
		attribution: 'Katarína Bulková<br>&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
	});

	let CartoDB_Positron = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
		attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
		subdomains: 'abcd',
		maxZoom: 20
	});

	let Stadia_AlidadeSmooth = L.tileLayer('https://tiles.stadiamaps.com/tiles/alidade_smooth/{z}/{x}/{y}{r}.png', {
		maxZoom: 20,
		attribution: '&copy; <a href="https://stadiamaps.com/">Stadia Maps</a>, &copy; <a href="https://openmaptiles.org/">OpenMapTiles</a> &copy; <a href="http://openstreetmap.org">OpenStreetMap</a> contributors'
	});

	let Stamen_TonerLite = L.tileLayer('https://stamen-tiles-{s}.a.ssl.fastly.net/toner-lite/{z}/{x}/{y}{r}.{ext}', {
		attribution: 'Map tiles by <a href="http://stamen.com">Stamen Design</a>, <a href="http://creativecommons.org/licenses/by/3.0">CC BY 3.0</a> &mdash; Map data &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
		subdomains: 'abcd',
		minZoom: 0,
		maxZoom: 20,
		ext: 'png'
	});


	let CyclOSM = L.tileLayer('https://{s}.tile-cyclosm.openstreetmap.fr/cyclosm/{z}/{x}/{y}.png', {
		maxZoom: 20,
		attribution: '<a href="https://github.com/cyclosm/cyclosm-cartocss-style/releases" title="CyclOSM - Open Bicycle render">CyclOSM</a> | Map data: &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
	});

	let map = L.map('map', {
		center: [49.196822238343486, 16.60474816825514],
		zoom: 13,
		zoomControl: false,
		layers: [CartoDB_Positron]
	});

	// clustering layer uses per-marker toggling, can be added directly
	map.addLayer(accidentsCluster);

	const baseLayers = {
		"Carto": CartoDB_Positron,
		"OpenStreetMap": OSM,
		"Stadia AlidadeSmooth": Stadia_AlidadeSmooth,
		"Stamen TonerLite": Stamen_TonerLite,
		"Cyclo OpenStreetMap": CyclOSM}

	const overlays = {
		"<span id='traffic_accidents'><i class='fa fa-map-marker red'></i> Traffic accidents</span>": accidentsCluster,
		"<span id='bike_accidents'><i class='fa fa-map-marker violet'></i> Bike accidents</span>": accidentsCluster,
		"<span id='pedestrian_accidents'><i class='fa fa-map-marker blue'></i> Pedestrian accidents</span>": accidentsCluster,
		"<i class='fa-regular fa-lightbulb'></i> Street lights": streetLightsLayer,
		"<i class='fa-solid fa-bus'></i> Bus Stops": publicTransportStopsLayer,
		"<i class='fa-solid fa-person-walking'></i> Pedestrian Crossings": pedestrianCrossingsLayer,
		"<i class='fa-solid fa-bicycle'></i> Bicycle Crossing": cyclingInfraSourceFiles["BicycleCrossing.shp.zip"],
		"<i class='fa-solid fa-bicycle'></i> Bicycle Path": cyclingInfraSourceFiles["BikePath.shp.zip"],
		"<i class='fa-solid fa-bicycle'></i> Separate Line for Taxi, Bicycle, Bus": cyclingInfraSourceFiles["ReservedLaneForTaxi_Bicycle_Bus.shp.zip"],
		"<i class='fa-solid fa-bicycle'></i> Bicycle Path in the Opposite direction (Lane)": cyclingInfraSourceFiles["BikePathInTheOppositeDirection(Lane).shp.zip"],
		"<i class='fa-solid fa-bicycle'></i> Cyclists riding in the opposite direction": cyclingInfraSourceFiles["CyclistsRidingInTheOppositeDirection.shp.zip"],
		"<i class='fa-solid fa-bicycle'></i> Dedicated bicycle line": cyclingInfraSourceFiles["DedicatedBicycleLane.shp.zip"],
		"<i class='fa-solid fa-bicycle'></i> Protective Line for Cyclists": cyclingInfraSourceFiles["ProtectiveLaneForCyclists.shp.zip"],
		"<i class='fa-solid fa-bicycle'></i> Marked Corridor for Cyclists": cyclingInfraSourceFiles["MarkedCorridorForCyclists.shp.zip"],
		"<i class='fa-solid fa-bicycle'></i> Entry Allowed for Cyclists": cyclingInfraSourceFiles["EntryAllowedForCyclists.shp.zip"],
		"<i class='fa-solid fa-bicycle'></i> No Entry for All Motor Vehicles": cyclingInfraSourceFiles["NoEntryForAllMotorVehicles.shp.zip"],
		"<i class='fa-solid fa-bicycle'></i> Path for Pedestrians and Cyclists (Separated)": cyclingInfraSourceFiles["PathForPedestriansAndCyclists(Separated).shp.zip"],
		"<i class='fa-solid fa-bicycle'></i> Path for Pedestrians and Cyclists (Joint)": cyclingInfraSourceFiles["PathForPedestriansAndCyclists(Unseparated).shp.zip"],
		"<i class='fa-solid fa-bicycle'></i> Pedestrian Path with Cyclists Allowed": cyclingInfraSourceFiles["PedestrianPathWithCyclistsAllowed.shp.zip"],
		"<i class='fa-solid fa-bicycle'></i> Prohibited Entry for Cyclists": cyclingInfraSourceFiles["ProhibitedEntryForCyclists.shp.zip"],
		"<i class='fa-solid fa-bicycle'></i> Canceled sections": cyclingInfraSourceFiles["TheSectionWasCanceled.shp.zip"],
		"<i class='fa-solid fa-bicycle'></i> Others": cyclingInfraSourceFiles["Others.shp.zip"],
		"<i class='fa-solid fa-arrow-up-right-dots'></i> Minimal (<5%)": streetSlopeSourceFiles["Min.shp.zip"],
		"<i class='fa-solid fa-arrow-up-right-dots'></i> Medium (5%-10%)": streetSlopeSourceFiles["Medium.shp.zip"],
		"<i class='fa-solid fa-arrow-up-right-dots'></i> Dangerous (10%-20%)": streetSlopeSourceFiles["Dangerous.shp.zip"],
		"<i class='fa-solid fa-arrow-up-right-dots'></i> Extreme (>20%)": streetSlopeSourceFiles["Extreme.shp.zip"]
	}

	generateOverlaysControl();

	// layer selector
	L.control.layers(baseLayers, [], {groupCheckboxes: true}).addTo(map);

	// zoom control
	L.control.zoom({
		position: 'bottomright'
	}).addTo(map)

	// sidebar
	L.control.sidebar('sidebar').addTo(map);

	// filtering
	let filterCategories = []

	let collision_with_category =  L.control.tagFilterButton({
		data: [
			'crash',
			'collision with a pedestrian',
			'collision with an animal',
			'collision with a moving non-rail vehicle',
			'collision with a fixed obstacle',
			'collision with tram',
			'collision with train',
			'collision with parked vehicle',
			'other',
		],
		filterOnEveryClick: true,
		icon: '<i class="fa-solid fa-car-burst"></i> Collision With'
	}).addTo(map);
	filterCategories.push(collision_with_category);

	let cause = L.control.tagFilterButton({
		data: [
			'improper driving style',
			'others',
			'speed adjustment',
			'violation of traffic signs or rules',
			'giving way',
			'overtaking',
			'technical defects'
		],
		filterOnEveryClick: true,
		icon: '<i class="fa fa-question"></i> Cause'
	}).addTo(map);
	filterCategories.push(cause);

	let alcoholCategory = L.control.tagFilterButton({
		data: [
			'DUI - blood alcohol content < 0,24‰',
			'DUI - blood alcohol content < 0,5‰ & >= 0,24‰',
			'DUI - blood alcohol content < 0,8‰ & >= 0,5‰',
			'DUI - blood alcohol content < 1,0‰ & >= 0,8‰',
			'DUI - blood alcohol content < 1,5‰ & >= 1,0‰',
			'DUI - blood alcohol content >= 1,5‰ ',
			'No',
			'not tested',
			'DUI - alcohol and drugs',
			'DUI - drugs'
		],
		filterOnEveryClick: true,
		icon: '<i class="fa fa-beer"></i> Alcohol'
	}).addTo(map);
	filterCategories.push(alcoholCategory);

	let causedByCategory = L.control.tagFilterButton({
		data: [
			'pedestrian',
			'other',
			'another road user',
			'forest or domestic animal',
			'vehicle technical defect',
			'communication obstacle',
			'motor vehicle driver',
			'driver of a non-motor vehicle',
		],
		filterOnEveryClick: true,
		icon: '<i class="fa-solid fa-person-circle-question"></i> Caused By'
	}).addTo(map);
	filterCategories.push(causedByCategory);

	let roadConditionCategory = L.control.tagFilterButton({
		data: [
			'different state of the road surface at the time of accidents',
			'mud on the road',
			'ice on the road - untreated',
			'ice on the road - treated',
			'sudden change in road conditions (frost on the bridge, local frost)',
			'wet surface',
			'dry surface, clean',
			'dry surface, dirty (sand, dust, leaves, gravel etc.)',
			'continuous snow layer, slush',
		],
		filterOnEveryClick: true,
		icon: '<i class="fa-solid fa-road-circle-exclamation"></i> Road Condition'
	}).addTo(map);
	filterCategories.push(roadConditionCategory);

	let weatherConditionsCategory = L.control.tagFilterButton({
		data: [
			'rain',
			'different difficult weather conditions',
			'fog',
			'beginning of the rain, light rain, drizzling etc.',
			'normal weather conditions',
			'gusting wind (side wind, whirlwind etc.)',
			'snowfall',
			'frost, icicles are formed',
		],
		filterOnEveryClick: true,
		icon: '<i class="fa-solid fa-cloud"></i> Weather Condition'
	}).addTo(map);
	filterCategories.push(weatherConditionsCategory);

	let visibilityCategory = L.control.tagFilterButton({
		data: [
			'at night - without public lighting, visibility unimpaired due to weather conditions',
			'at night - without public lighting, visibility impaired due to weather conditions (fog, rain, snowfall etc.)',
			'at night - with public lighting, visibility unimpaired due to weather conditions',
			'at night - with public lighting, visibility impaired due to weather conditions (fog, rain, snowfall etc.)',
			'during the day, visibility not impaired  weather conditions',
			'during the day, reduced visibility (dawn, dusk)',
			'during the day, poor visibility due to weather conditions (fog, snow, rain, etc.)',
		],
		filterOnEveryClick: true,
		icon: '<i class="fa-solid fa-smog"></i> Visibility'
	}).addTo(map);
	filterCategories.push(visibilityCategory);

	let viewConditionCategory = L.control.tagFilterButton({
		data: [
			'good view',
			'bad view - other reason',
			'view blocked by a stationary vehicle',
			'bad view - due to surrounding construction (buildings, full railings, etc.)',
			'bad view - due to the course of the road, or the longitudinal profile or routing (unclear top of the climb, road cut, etc.)',
			'bad view - due to vegetation - temporary (grass, grain etc.)',
			'bad view - due to vegetation - permanent (trees, bushes, etc.)',
		],
		filterOnEveryClick: true,
		icon: '<i class="fa-solid fa-eye"></i> View Condition'
	}).addTo(map);
	filterCategories.push(viewConditionCategory);

	let accidentPlaceCategory = L.control.tagFilterButton({
		data: [
			'bridge, overpass, underpass, tunnel',
			'parking lot adjacent to the road',
			'pedestrain crossing',
			'near a pedestrian crossing (within 20 m)',
			'exit from the parking lot, forest path, etc.',
			'tram, bus, trolleybus stop with a boarding island',
			'tram, bus, trolleybus stop without a boarding island',
			'fuel pump',
			'railway crossing not secured by barriers or light warning devices',
			'railway crossing secured',
			'none of the above',
		],
		filterOnEveryClick: true,
		icon: '<i class="fa-solid fa-location-pin"></i> Location'
	}).addTo(map);
	filterCategories.push(accidentPlaceCategory);

	let roadTypeCategory = L.control.tagFilterButton({
		name: 'Road type category',
		data: [
			'highway',
			'local road',
			'controlled road (in specific areas)',
			'specific-purpose road - others(parking, rest areas, etc.)',
			'specific-purpose road - field and forest roads, etc.',
			'1st class roads',
			'2nd class roads',
			'3rd class roads',
			'road junction (crossroad controlled in specific areas)',
		],
		filterOnEveryClick: true,
		icon: '<i class="fa fa-road"></i> Road Type'
	}).addTo(map);
	filterCategories.push(roadTypeCategory);

	// enable Prunecluster filtering
	filterCategories.forEach(cat => cat.enablePruneCluster(accidentsCluster));

	// Add filter to the sidebar
	function moveFilterIconToSidebar() {
		console.log("Moving filter to the sidebar");
		let filter_buttons = document.getElementsByClassName("leaflet-bar easy-button-container leaflet-control");
		let button_container = filter_buttons[0].parentNode;
		button_container.classList.remove('leaflet-top');
		let sidebar_container = document.getElementById('filters');
		sidebar_container.append(button_container);
	}
	moveFilterIconToSidebar();

	// create date filter
	function DateRangeFilter(startDate, endDate) {
		trafficAccidentMarkers.map(marker => marker.filtered = true);
		let traffic_matching = trafficAccidentMarkers.filter(marker => marker.date >= startDate && marker.date <= endDate)
		console.log("Found " + traffic_matching.length + " matching entries in pedestrian_accidents")
		traffic_matching.map(marker => marker.filtered = false);

		bikeAccidentMarkers.map(marker => marker.filtered = true);
		let bike_matching = bikeAccidentMarkers.filter(marker => marker.date >= startDate && marker.date <= endDate)
		console.log("Found " + bike_matching.length + " matching entries in pedestrian_accidents")
		bike_matching.map(marker => marker.filtered = false);

		pedestrianAccidentMarkers.map(marker => marker.filtered = true);
		let ped_matching = pedestrianAccidentMarkers.filter(marker => marker.date >= startDate && marker.date <= endDate)
		console.log("Found " + ped_matching.length + " matching entries in pedestrian_accidents")
		ped_matching.map(marker => marker.filtered = false);

		accidentsCluster.ProcessView();
	}

	function DateCustomSelect() {
		let year_el = document.getElementById('year');
		let year_sel = year_el.parentNode.firstElementChild.firstElementChild.checked;

		let month_el =  document.getElementById('month');
		let month_sel = month_el.parentNode.firstElementChild.firstElementChild.checked;

		let day_el = document.getElementById('day')
		let day_sel = day_el.parentNode.firstElementChild.firstElementChild.checked;

		let weekday_el = document.getElementById('weekday')
		let weekday_sel = weekday_el.parentNode.firstElementChild.firstElementChild.checked;

		let all_markers = [trafficAccidentMarkers, bikeAccidentMarkers, pedestrianAccidentMarkers]

		// disable all markers
		all_markers.forEach(removeMarkerSet);

		let filtered_set = trafficAccidentMarkers.concat(bikeAccidentMarkers).concat(pedestrianAccidentMarkers);

		if (year_sel){
			filtered_set = filtered_set.filter(value => value.date.getFullYear().toString() === year_el.selectedOptions[0].value
			)
		}
		if (month_sel) {
			filtered_set = filtered_set.filter(value => value.date.getMonth().toString() === month_el.selectedOptions[0].value
			)
		}
		if (day_sel) {
			filtered_set =filtered_set.filter(value => value.date.getDate().toString() === day_el.selectedOptions[0].value
			)
		}
		if (weekday_sel) {
			filtered_set = filtered_set.filter(value => value.date.getDay().toString() === weekday_el.selectedOptions[0].value
			)
		}
		console.log(filtered_set.length + " markers selected");
		filtered_set.map(marker => marker.filtered = false);
		accidentsCluster.ProcessView();



	}



	// EVENT HANDLERS
	function toggleTrafficAccidents(el) {
		if (!el.classList.contains("enabled")) {
			console.log("Adding traffic accidents");
			el.classList.add("enabled");
			addTrafficAccidents();
		} else {
			console.log("Removing traffic accidents");
			el.classList.remove("enabled")
			removeMarkerSet(trafficAccidentMarkers);
		}
	}

	function toggleBikeAccidents(el) {
		if (!el.classList.contains("enabled")) {
			console.log("Adding bike accidents");
			el.classList.add("enabled");

			addBikeAccidents();
		} else {
			console.log("Removing bike accidents");
			el.classList.remove("enabled")
			removeMarkerSet(bikeAccidentMarkers);
		}}

	function togglePedestrianAccidents(el) {
		if (!el.classList.contains("enabled")) {
			console.log("Adding pedestrian accidents");
			el.classList.add("enabled");
			addPedestrianAccidents();
		} else {
			console.log("Removing pedestrian accidents");
			el.classList.remove("enabled")
			removeMarkerSet(pedestrianAccidentMarkers);
		}}

	function toggleAllAccidents() {
		if (this.checked) {
			console.log("Adding all accidents");
			addTrafficAccidents();
			addBikeAccidents();
			addPedestrianAccidents();
		} else {
			console.log("Removing all accidents");
			removeMarkerSet(trafficAccidentMarkers);
			removeMarkerSet(bikeAccidentMarkers);
			removeMarkerSet(pedestrianAccidentMarkers);
		}
	}

	// document.getElementById("traffic_accidents").parentNode.parentNode.firstElementChild.addEventListener ("change", toggleTrafficAccidents, false);
	// document.getElementById("bike_accidents").parentNode.parentNode.firstElementChild.addEventListener ("change", toggleBikeAccidents, false);
	// document.getElementById("pedestrian_accidents").parentNode.parentNode.firstElementChild.addEventListener ("change", togglePedestrianAccidents, false);

</script>
</body>
</html>
