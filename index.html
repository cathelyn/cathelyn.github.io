<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">

	<title>Brno Accident Data Visualization</title>

	<!--	<link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet">-->
	<script src="https://kit.fontawesome.com/1f4d66b7c3.js" crossorigin="anonymous"></script>

	<link rel="shortcut icon" type="image/png" href="docs/images/favicon.png" />
	<link rel="stylesheet" href="css/style.css" />
	<link rel="stylesheet" href="leaflet/leaflet.css" />
	<link rel="stylesheet" href="css/LeafletStyleSheet.css" />
	<link rel="stylesheet" href="css/leaflet-sidebar.css" />
	<link rel="stylesheet" href="css/leaflet-tag-filter-button.css" />
	<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/daterangepicker/daterangepicker.css" />


	<script type="text/javascript" src="https://cdn.jsdelivr.net/jquery/latest/jquery.min.js"></script>
	<script type="text/javascript" src="https://cdn.jsdelivr.net/momentjs/latest/moment.min.js"></script>
	<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/daterangepicker/daterangepicker.min.js"></script>

	<!--	Leaflet -->
	<script src="leaflet/leaflet.js"></script>
	<!--	Prune clustering-->
	<script src="js/PruneCluster.js"></script>
	<!--	Leaflet sidebar-->
	<script src="js/leaflet-sidebar.js"></script>
	<!--	Filtering -->
	<script src="js/leaflet-easy-button.js"></script>
	<script src="js/leaflet-tag-filter-button.js"></script>

	<!--	Data sources TODO: Find better way to store-->

	<script src="sources/bike_accidents.js"></script>
	<script src="sources/traffic_accidents.js"></script>
	<script src="sources/ped_accidents.js"></script>
	<script src="sources/pub_trans_stops_lat_lon_name.js"></script>
	<script src="sources/street_lights_lat_lon_date.js"></script>

</head>
<body>

<!-- SIDEBAR -->
<div id="sidebar" class="sidebar collapsed">
	<!-- Nav tabs -->
	<div class="sidebar-tabs">
		<ul role="tablist">
			<li><a href="#home" role="tab"><i class="fa fa-bars"></i></a></li>
			<li><a href="#dates" role="tab"><i class="fa-solid fa-calendar-days"></i></a></li>
			<li ><a href="#filter" role="tab"><i class="fa fa-filter"></i></a></li>
		</ul>

		<ul role="tablist">
			<li><a href="#settings" role="tab"><i class="fa fa-gear"></i></a></li>
		</ul>
	</div>

	<!-- Tab panes -->
	<div class="sidebar-content">
		<div class="sidebar-pane" id="home">
			<h1 class="sidebar-header">
				Brno accident data visualization
				<span class="sidebar-close"><i class="fa fa-caret-left"></i></span>
			</h1>
			<!--			TODO: Decide what to do with this menu -->
			This is a project.

		</div>

		<div class="sidebar-pane" id="dates">
			<h1 class="sidebar-header">Date selector<span class="sidebar-close"><i class="fa fa-caret-left"></i></span></h1>
			<input type="text" name="dates" />
			<script>
				$('input[name="dates"]').daterangepicker({
					opens: 'right',
					startDate: "01/01/2010",
					endDate: "12/31/2021",
					showDropdowns: true,
					minYear: 2010,
					maxYear: 2021,
				},
				function(start, end, label) {
					date_filter(start, end);
				}
				);
			</script>
		</div>


		<div class="sidebar-pane" id="filter">
			<h1 class="sidebar-header">Filters<span class="sidebar-close"><i class="fa fa-caret-left"></i></span></h1>
			<div id="filters">


			</div>

		</div>

		<div class="sidebar-pane" id="settings">
			<h1 class="sidebar-header">Settings<span class="sidebar-close"><i class="fa fa-caret-left"></i></span></h1>
		</div>
	</div>
</div>


<div id="map" class="sidebar-map" style="width: 100vw; height: 100vh;"></div>

<script>
	// CONSTANTS
	const categories_colors = ['rgba(255,75,0,0.6)', 'rgba(160,61,229,0.6)', 'rgba(3,170,234,0.6)'];
	const pi2 = Math.PI * 2;
	// categories configuration
	const traffic_category = 0
	const bike_category = 1
	const pedestrian_category = 2
	// END CONSTANTS

	// DATA
	// START LAYER SETUP
	// one main layer group
	let accidents = L.layerGroup();
	// main clustering layer
	let accidents_cluster = new PruneClusterForLeaflet(160);


	// other info layers
	let pedestrian_crossings_layer = L.layerGroup();
	let public_transport_stops_layer = L.layerGroup();
	let street_lights_layer = L.layerGroup();
	let street_slopes_layer = L.layerGroup();
	// END LAYER SETUP

	// Filter categories definition
	const categories = ['alcohol']

	// START ICON (MARKER) GENERATOR
	// icons for separate categories
	accidents_cluster.BuildLeafletClusterIcon = function(cluster) {
		let e = new L.Icon.MarkerCluster();

		e.stats = cluster.stats;
		e.population = cluster.population;
		return e;
	};

	L.Icon.MarkerCluster = L.Icon.extend({
		options: {
			iconSize: new L.Point(44, 44),
			className: 'prunecluster leaflet-markercluster-icon'
		},

		createIcon: function () {
			// based on L.Icon.Canvas from shramov/leaflet-plugins (BSD licence)
			let e = document.createElement('canvas');
			this._setIconStyles(e, 'icon');
			let s = this.options.iconSize;
			e.width = s.x;
			e.height = s.y;
			this.draw(e.getContext('2d'), s.x, s.y);
			return e;
		},

		createShadow: function () {
			return null;
		},

		draw: function(canvas) {
			let start = 0;
			for (let i = 0, l = categories_colors.length; i < l; ++i) {

				let size = this.stats[i] / this.population;


				if (size > 0) {
					canvas.beginPath();
					canvas.moveTo(22, 22);
					canvas.fillStyle = categories_colors[i];
					let from = start,
							to = start + size * pi2;

					if (to < from) {
						from = start;
					}
					canvas.arc(22,22,22, from, to);

					start = start + size*pi2;
					canvas.lineTo(22,22);
					canvas.fill();
					canvas.closePath();
				}

			}

			canvas.beginPath();
			canvas.fillStyle = "rgba(255, 255, 255, 0)"; // TODO: Ask about this
			let diameter = 13;
			canvas.arc(22, 22, diameter, 0, Math.PI*2);
			canvas.fill();
			canvas.closePath();

			canvas.fillStyle = '#000000';
			canvas.textAlign = 'center';
			canvas.textBaseline = 'middle';
			canvas.font = 'bold 12px sans-serif';

			canvas.fillText(this.population, 22, 22, 40);
		}
	});

	function fontAwesomeMapMarkerIcon()
	{
		return new L.divIcon({
					html: '<i class="fa fa-map-marker fa-2x"></i>',
					iconSize: [40, 40],
					className: "MapMarkerIcon",
				}
		)
	}

	// END ICON (MARKER) GENERATOR

	// START MARKER GENERATOR FROM DATA

	// markers storage for quick adding - deleting
	let traffic_accident_markers = []
	let bike_accident_markers = []
	let pedestrian_accident_markers = []

	function add_accident(dataset, markers_array, category)
	/**
	 * Create and add markers for the accidents based on the date in @param dataset. Created markers are also stored
	 * in @param markers_array for further manipulation and filtering. Each marker is assigned a respective category.
	 * @param dataset input data in js array format consisting of comma-separated lat,lon,YYYY,MM,DD values
	 * @param markers_array js array for storing created markers
	 * @param category representation of category for filtering/icon composition purposes
	 */
	{
		if (markers_array.length > 0){
			console.log("Registering " + markers_array.length + " markers");
			markers_array.map(marker => {marker.filtered = false})
		} else {

			let colour_class = "black";
			if (category === 0) {
				colour_class = "red";
			}
			else if (category === 1) {
				colour_class = "violet";
			}
			else if (category === 2) {
				colour_class = "blue";
			}


			console.log("Building markers anew");
			dataset.forEach(value => {
				let marker = create_cluster_marker(value);
				marker.date = new Date(value.datetime);
				marker.filtered = true;
				marker.category = category;


				marker.data.tags = [
					value.collision_with,
					value.cause,
					value.alcohol,
					value.caused_by,
					value.road_condition,
					value.weather,
					value.visibility,
					value.view_condition,
					value.accident_place,
					value.road_type
				]

				marker.data.icon = fontAwesomeMapMarkerIcon();
				marker.data.icon.options.className = "MapMarkerIcon " + colour_class;
				var keys = Object.keys(value);
				let info = "";
				for (var i = 0; i < keys.length; i++) {
					info += keys[i] + ": " + value[keys[i]] + "<br>"
				}

				marker.data.popup = "<b>" + info + "</b>"; // TODO: make popup
				markers_array.push(marker);
				accidents_cluster.RegisterMarker(marker)}
			);
		}
		accidents_cluster.ProcessView();
	}

	function add_traffic_accidents() {
		add_accident(traffic_accidents_json, traffic_accident_markers, traffic_category);
	}

	function add_bike_accidents() {
		add_accident(bike_accidents_json, bike_accident_markers, bike_category);
	}

	function add_pedestrian_accidents() {
		add_accident(pedestrian_accidents_json, pedestrian_accident_markers, pedestrian_category);
	}

	function remove_marker_set(marker_set) {
		marker_set.map(marker => {marker.filtered = true})
		accidents_cluster.ProcessView();
	}

	// init the clusters
	add_traffic_accidents();
	add_bike_accidents();
	add_pedestrian_accidents();

	public_transportation_stops.forEach(add_public_trans_stops);
	street_lights.forEach(add_street_lights);

	function create_cluster_marker(value) {
		return new PruneCluster.Marker(
				value.point_y,
				value.point_x
		)
	}

	function add_public_trans_stops(value) {
		L.circle([value.split(",")[0], value.split(",")[1]], {
			stroke: false,
			fillColor: '#000000',
			fillOpacity: 0.7,
			radius: 2,
		}).addTo(public_transport_stops_layer).bindPopup(value.split(",")[2]);
	}

	function add_street_lights(value) {
		// TODO: Make this faster (probably run in the bg on startup or use CircleMarker)
		L.circle([value.split(",")[0], value.split(",")[1]], {
			stroke: false,
			fillColor: '#ffac00',
			fillOpacity: 0.5,
			radius: 1.5,
		}).addTo(street_lights_layer);
	}

	accidents.addLayer(accidents_cluster);


	let OSM = L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
		maxZoom: 19,
		attribution: 'Katarína Bulková<br>&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
	});

	var CartoDB_Positron = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
		attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
		subdomains: 'abcd',
		maxZoom: 20
	});

	let map = L.map('map', {
		center: [49.196822238343486, 16.60474816825514],
		zoom: 13,
		zoomControl: false,
		layers: [OSM]
	});

	const base_layers = {
		"OpenStreetMap": OSM,
		"Carto": CartoDB_Positron}
	const overlays = {
		"<span id='traffic_accidents'><i class='fa fa-map-marker red'></i> Traffic accidents</span>": accidents,
		"<span id='bike_accidents'><i class='fa fa-map-marker violet'></i> Bike accidents</span>": accidents,
		"<span id='pedestrian_accidents'><i class='fa fa-map-marker blue'></i> Pedestrian accidents</span>": accidents,
		"Street lights": street_lights_layer,
		"<i class='fa fa-bus'></i> Bus Stops": public_transport_stops_layer,

	}


	// layer selector
	L.control.layers(base_layers, overlays).addTo(map);

	// zoom control
	L.control.zoom({
		position: 'bottomright'
	}).addTo(map)

	// sidebar
	L.control.sidebar('sidebar').addTo(map);

	// filtering
	let filter_categories = []

	let collision_with_category =  L.control.tagFilterButton({
		data: [
			'crash',
			'collision with a pedestrian',
			'collision with an animal',
			'collision with a moving non-rail vehicle',
			'collision with a fixed obstacle',
			'collision with tram',
			'collision with train',
			'collision with parked vehicle',
			'other',
		],
		filterOnEveryClick: true,
		icon: '<i class="fa-solid fa-car-burst"></i> Collision With'
	}).addTo(map);
	filter_categories.push(collision_with_category);

	let cause = L.control.tagFilterButton({
		data: [
			'improper driving style',
			'others',
			'speed adjustment',
			'violation of traffic signs or rules',
			'giving way',
			'overtaking',
			'technical defects'
		],
		filterOnEveryClick: true,
		icon: '<i class="fa fa-question"></i> Cause'
	}).addTo(map);
	filter_categories.push(cause);

	let alcohol_category = L.control.tagFilterButton({
		data: [
			'DUI - blood alcohol content < 0,24‰',
			'DUI - blood alcohol content < 0,5‰ & >= 0,24‰',
			'DUI - blood alcohol content < 0,8‰ & >= 0,5‰',
			'DUI - blood alcohol content < 1,0‰ & >= 0,8‰',
			'DUI - blood alcohol content < 1,5‰ & >= 1,0‰',
			'DUI - blood alcohol content >= 1,5‰ ',
			'No',
			'not tested',
			'DUI - alcohol and drugs',
			'DUI - drugs'
		],
		filterOnEveryClick: true,
		icon: '<i class="fa fa-beer"></i> Alcohol'
	}).addTo(map);
	filter_categories.push(alcohol_category);

	let caused_by_category = L.control.tagFilterButton({
		data: [
			'pedestrian',
			'other',
			'another road user',
			'forest or domestic animal',
			'vehicle technical defect',
			'communication obstacle',
			'motor vehicle driver',
			'driver of a non-motor vehicle',
		],
		filterOnEveryClick: true,
		icon: '<i class="fa-solid fa-person-circle-question"></i> Caused By'
	}).addTo(map);
	filter_categories.push(caused_by_category);

	let road_condition_category = L.control.tagFilterButton({
		data: [
			'different state of the road surface at the time of accidents',
			'mud on the road',
			'ice on the road - untreated',
			'ice on the road - treated',
			'sudden change in road conditions (frost on the bridge, local frost)',
			'wet surface',
			'dry surface, clean',
			'dry surface, dirty (sand, dust, leaves, gravel etc.)',
			'continuous snow layer, slush',
		],
		filterOnEveryClick: true,
		icon: '<i class="fa-solid fa-road-circle-exclamation"></i> Road Condition'
	}).addTo(map);
	filter_categories.push(road_condition_category);

	let weather_conditions_category = L.control.tagFilterButton({
		data: [
			'rain',
			'different difficult weather conditions',
			'fog',
			'beginning of the rain, light rain, drizzling etc.',
			'normal weather conditions',
			'gusting wind (side wind, whirlwind etc.)',
			'snowfall',
			'frost, icicles are formed',
		],
		filterOnEveryClick: true,
		icon: '<i class="fa-solid fa-cloud"></i> Weather Condition'
	}).addTo(map);
	filter_categories.push(weather_conditions_category);

	let visibility_category = L.control.tagFilterButton({
		data: [
			'at night - without public lighting, visibility unimpaired due to weather conditions',
			'at night - without public lighting, visibility impaired due to weather conditions (fog, rain, snowfall etc.)',
			'at night - with public lighting, visibility unimpaired due to weather conditions',
			'at night - with public lighting, visibility impaired due to weather conditions (fog, rain, snowfall etc.)',
			'during the day, visibility not impaired  weather conditions',
			'during the day, reduced visibility (dawn, dusk)',
			'during the day, poor visibility due to weather conditions (fog, snow, rain, etc.)',
		],
		filterOnEveryClick: true,
		icon: '<i class="fa-solid fa-smog"></i> Visibility'
	}).addTo(map);
	filter_categories.push(visibility_category);

	let view_condition_category = L.control.tagFilterButton({
		data: [
			'good view',
			'bad view - other reason',
			'view blocked by a stationary vehicle',
			'bad view - due to surrounding construction (buildings, full railings, etc.)',
			'bad view - due to the course of the road, or the longitudinal profile or routing (unclear top of the climb, road cut, etc.)',
			'bad view - due to vegetation - temporary (grass, grain etc.)',
			'bad view - due to vegetation - permanent (trees, bushes, etc.)',
		],
		filterOnEveryClick: true,
		icon: '<i class="fa-solid fa-eye"></i> View Condition'
	}).addTo(map);
	filter_categories.push(view_condition_category);

	let accident_place_category = L.control.tagFilterButton({
		data: [
			'bridge, overpass, underpass, tunnel',
			'parking lot adjacent to the road',
			'pedestrain crossing',
			'near a pedestrian crossing (within 20 m)',
			'exit from the parking lot, forest path, etc.',
			'tram, bus, trolleybus stop with a boarding island',
			'tram, bus, trolleybus stop without a boarding island',
			'fuel pump',
			'railway crossing not secured by barriers or light warning devices',
			'railway crossing secured',
			'none of the above',
		],
		filterOnEveryClick: true,
		icon: '<i class="fa-solid fa-location-pin"></i> Location'
	}).addTo(map);
	filter_categories.push(accident_place_category);

	let road_type_category = L.control.tagFilterButton({
		name: 'Road type category',
		data: [
			'highway',
			'local road',
			'controlled road (in specific areas)',
			'specific-purpose road - others(parking, rest areas, etc.)',
			'specific-purpose road - field and forest roads, etc.',
			'1st class roads',
			'2nd class roads',
			'3rd class roads',
			'road junction (crossroad controlled in specific areas)',
		],
		filterOnEveryClick: true,
		icon: '<i class="fa fa-road"></i> Road Type'
	}).addTo(map);
	filter_categories.push(road_type_category);

	// enable Prunecluster filtering
	filter_categories.forEach(cat => cat.enablePruneCluster(accidents_cluster));

	// Add filter to the sidebar
	function move_filter_icon_to_sidebar() {
		console.log("Moving filter to the sidebar");
		let filter_buttons = document.getElementsByClassName("leaflet-bar easy-button-container leaflet-control");
		let button_container = filter_buttons[0].parentNode;
		button_container.classList.remove('leaflet-top');
		let sidebar_container = document.getElementById('filters');
		sidebar_container.append(button_container);
	}
	move_filter_icon_to_sidebar();

	// create date filter
	function date_filter(start_date, end_date) {
		traffic_accident_markers.map(marker => marker.filtered = true);
		let traffic_matching = traffic_accident_markers.filter(marker => marker.date >= start_date && marker.date <= end_date)
		console.log("Found " + traffic_matching.length + " matching entries in pedestrian_accidents")
		traffic_matching.map(marker => marker.filtered = false);

		bike_accident_markers.map(marker => marker.filtered = true);
		let bike_matching = bike_accident_markers.filter(marker => marker.date >= start_date && marker.date <= end_date)
		console.log("Found " + bike_matching.length + " matching entries in pedestrian_accidents")
		bike_matching.map(marker => marker.filtered = false);

		pedestrian_accident_markers.map(marker => marker.filtered = true);
		let ped_matching = pedestrian_accident_markers.filter(marker => marker.date >= start_date && marker.date <= end_date)
		console.log("Found " + ped_matching.length + " matching entries in pedestrian_accidents")
		ped_matching.map(marker => marker.filtered = false);

		accidents_cluster.ProcessView();
}





	// EVENT HANDLERS
	function toggle_traffic_accidents() {
		if (this.checked) {
			console.log("Adding traffic accidents");
			add_traffic_accidents();
		} else {
			console.log("Removing traffic accidents");
			remove_marker_set(traffic_accident_markers);
		}
	}

	function toggle_bike_accidents() {
		if (this.checked) {
			console.log("Adding bike accidents");
			add_bike_accidents();
		} else {
			console.log("Removing bike accidents");
			remove_marker_set(bike_accident_markers);
		}}

	function toggle_pedestrian_accidents() {
		if (this.checked) {
			console.log("Adding pedestrian accidents");
			add_pedestrian_accidents();
		} else {
			console.log("Removing pedestrian accidents");
			remove_marker_set(pedestrian_accident_markers);
		}}

	document.getElementById("traffic_accidents").parentNode.parentNode.firstElementChild.addEventListener ("change", toggle_traffic_accidents, false);
	document.getElementById("bike_accidents").parentNode.parentNode.firstElementChild.addEventListener ("change", toggle_bike_accidents, false);
	document.getElementById("pedestrian_accidents").parentNode.parentNode.firstElementChild.addEventListener ("change", toggle_pedestrian_accidents, false);

</script>
</body>
</html>
